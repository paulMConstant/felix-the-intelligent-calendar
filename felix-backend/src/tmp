
    /// Updates the possible insertion times of an activity.
    /// Returns true if the possible insertion times were computed, else false.
    /// This function must be called before
    /// possible_insertion_times_of_activity_with_associated_cost.
    ///
    /// # Errors
    ///
    /// Returns Err if the activity with given id is not found.
    pub(crate) fn update_possible_insertion_times_of_activity(
        &mut self,
        schedules_of_participants: &[WorkHoursAndActivityDurationsSorted],
        concerned_activity_id: ActivityId,
    ) -> Result<bool> {
        let concerned_activity = self.get_by_id(concerned_activity_id)?;

        let possible_beginnings_are_computed = if self
            .possible_beginnings_pool
            .activity_beginnings_are_up_to_date(&concerned_activity_id)
        {
            true
        } else {
            let maybe_possible_beginnings = self
                .possible_beginnings_pool
                .poll_and_fuse_possible_beginnings(&schedules_of_participants, &concerned_activity);

            if maybe_possible_beginnings.is_some() {
                // If the result is valid, store it into the activity computation data.
                let result =
                    maybe_possible_beginnings.expect("Maybe result should be some but is not");
                let activity = self
                    .get_mut_by_id(concerned_activity_id)
                    .expect("Getting activity which does not exist");
                activity
                    .computation_data
                    .set_possible_insertion_times_if_no_conflict(result);
                true
            } else {
                false
            }
        };
        Ok(possible_beginnings_are_computed)
    }


    /// Returns the possible beginnings of an activity if it is up to date or if
    /// the computation results are up.
    /// If neither is the case, returns None.
    ///
    /// # Panics
    ///
    /// Panics if the activity with given id is not found.
    pub(crate) fn possible_insertion_times_of_activity_with_associated_cost(
        &mut self,
        schedules_of_participants: &[WorkHoursAndActivityDurationsSorted],
        concerned_activity_id: ActivityId,
    ) -> Option<BTreeSet<InsertionCost>> {
       self.activities
           .get_by_id(concerned_activity_id)
           .expect("Activity with id {} does not exist", concerned_activity_id)
           .insertion_costs()
           .lock()
           .unwrap()
           .clone()

        //let possible_beginnings_are_computed = self.update_possible_insertion_times_of_activity(
            //schedules_of_participants,
            //concerned_activity_id,
        //)?;

        //let possible_beginnings = if possible_beginnings_are_computed {
            // Filter & compute the cost of each possible beginning
            //let (static_data, insertion_data) = self.fetch_computation();

            //let (&index_of_activity, _id) = self
                //.last_fetch_computation_index_to_id_map
                //.iter()
                //.find(|&(_index, id)| id == &concerned_activity_id)
                //.expect("Could not find activity");

            //let insertion_costs_of_activity =
                //&compute_insertion_costs(&static_data, &insertion_data, index_of_activity);

            //Some(
                //insertion_costs_of_activity
                    //.iter()
                    //.map(|insertion_cost_minutes| InsertionCost {
                        //beginning: Time::from_total_minutes(
                            //insertion_cost_minutes.beginning_minutes,
                        //),
                        //cost: insertion_cost_minutes.cost,
                    //})
                    //.collect::<BTreeSet<_>>(),
            //)
        //} else {
            //None
        //};
        //Ok(possible_beginnings)
    }
